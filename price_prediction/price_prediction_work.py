# -*- coding: utf-8 -*-
"""price_prediction_work.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bnYCTZjVApSyz14sg_uonSY5doj6XaWs

# "Прогнозирование цены бетона для строительной компании" #

## Введение ##

Хочу начать с того, что аналитический центр по поручению Правительства совместно с Минэкономразвития и другими федеральными органами исполнительной власти разрабатывает систему мониторинга цен на продовольственные и непродовольственные товары и прогнозирования их доступности. 
Это говорит о том, что тема прогнозирования цен на товары и услуги является достаточно важной и актуальной.

### Постановка задачи: ###
Написать доклад на тему прогнозирования цены бетона для строительной компании.

### Цель: ###
1.	Провести обзор и анализ методов прогнозирования цен на товары;
2.	Определить и обосновать выбор инструментальных средств и методов разработки;
3.	Провести анализ рисков и факторов, влияющих на изменение цены на бетон;
4.	Провести сбор и анализ информации для обучения нейронной сети;
5.	Разработать и описать программу для прогнозирования цены бетона.

## 1. Аналитическая часть ##

## 1.1. Про бетон и что с ним "едят" ##

Бетон – это искусственный каменный материал для строительства, который получается в результате формирования и затвердевания правильно подобранной смеси, которое в большинстве случаев включает в себя цемент, песок, воду и армирующий материал (например, щебень). Чаще всего используют семь без армирующего материала.

Производится на бетонных заводах, например, на заводе «СпецМонолитСтрой». Бетон может поставляться в разных состояниях: готовая смесь (непосредственно для поставки на стройплощадку), сухая смесь (для продажи в строительных магазинах). 

Поподробнее о необходимых компонентах:
1.	Песок. Добывается в песчаных карьерах, так как для производства необходим песок со специальной кристаллической формой;
2.	Цемент. Производится по определённому процессу. Сырьевые компоненты добываются в специальных карьерах.

![1.png](https://drive.google.com/uc?export=view&id=1RN1sRl5_KxQb-EO9kuuSlMPSpGT9iXrl)

Рисунок 1. Процесс производства цемента.

## 1.2. Теория по прогнозированию цен на товары. ##

__Прогнозирование__ - это одна из форм получения информации о будущем. В отличие от планов, прогнозирование позволяет лишь предвидеть ситуацию и разработать приблизительную модель поведения в будущем, основываясь на фактах прошлого. Например, успешное прогнозирование цен на строительные материалы, даёт возможность строительной компании более точно составить смету (расчёт предстоящих расходов на осуществление какой-либо деятельности) на проект.

В общем и целом, прогнозирование цен является задачей __прогнозирования временных рядов__. __Временной ряд__ - это собранные в разные моменты времени статистический материал о значении каких-либо параметров исследуемого процесса. Примерами временных рядов является:
*	Рыночные цены;
*	Объёмы продаж в торговых сетях;
*	Объёмы потребления;
*	Объёмы грузовых и пассажирских перевозок;
*	Дорожный трафик (прогнозирование пробок).

Основные явления, влияющие на прогнозирование временных рядов:
*	Тренды (основная тенденция изменения чего-либо);
*	Сезонности (переодические колебания);
*	Разладки (смены модели ряда).

Виды моделей прогнозирования временных рядов:
*	Регрессионные модели прогнозирования;
*	Авторегриссионные модели прогнозирования (ARIMAX, GARCH, ARDLM);
*	Модели экспоненциального сглаживания (ES);
*	Модель по выборке максимального подобия (MMSP);
*	Модель на нейронных сетях (ANN);
*	Модель на цепях Маркова (Markov chains);
*	Модель на классификационно-регрессионных деревьях (CART);
*	Модель на основе генетического алгоритма (GA);
*	Модель на опорных векторах (SVM);
*	Модель на основе передаточных функций (TF);
*	Модель на нечётной логике (FL).

Наиболее популярными моделями прогнозирования временных рядов являются нейронные сети и ARIMAX, поэтому для решения поставленной задачи выбор пал на нейронные сети, а если быть точнее на рекуррентные нейронные сети. __Рекуррентные НС__ – это сети в которых нейроны запоминают предыдущие значения. Также можно использовать классические виды нейронных сетей, весь выбор зависит от поставленной задачи.

Одной из популярной и надёжной разновидностью рекуррентной сети является __долгая краткосрочная память LSTM__ (Long short-term memory), изображено на рисунке 2.

![LSTM.png](https://drive.google.com/uc?export=view&id=1H5lWIo2MvqOUXKP-hqsJRuByTsxQyPMX)

Рисунок 2. LSTM - долгая крткосрочная память.

Преимуществом LSTM является, потому что, имеет свойство запоминать предыдущие значения, решать что выделить и что удалить, но имеет множество коэффициентов, весов, следовательно, имеет большой объём и долгое обучение. Позже придумали упрощение LSTM – __управляемы рекуррентные блоки GRU__ (Gated Recurrent Units), изображено на рисунке 3. 

![GRU.png](https://drive.google.com/uc?export=view&id=1PB-efrgvFwJ2XNnNZ-H2Hjt5zL-dUP7F)

Рисунок 3. GRU - управляемые рекуррентные блоки.

Обе рекуррентные сети по эффективности схожи, но исходя из их представления можно выделить определённые факторы:
*	Из-за большей сохраняемой информации LSTM улавливает лучше изменение трендов и показывает более точное предсказание временных рядов;
*	Из-за лучшего быстродействия и уменьшения сохраняемой информации GRU улавливает общее представление направления прогноза временного ряда.

Если представлять работу данных рекуррентных сетей в виде графиков, то у GRU он будет более плавным, без резких скачков, а у LSTM более точный.

## 1.3.	Риски и факторы, влияющие на изменение цены на бетон. ##
Многочисленны примеры ситуаций, связанных с социальными, технологическими, экономическими, политехническими, экологическими и другими рисками. Известны различные виды критериев, используемых в теории принятия решений в условиях неопределённости (риска). Из-за противоречивости решений, получаемых по различным критериям, очевидна необходимость применения оценок экспертов.

Факторы влияющие на изменения цены:
*	Спрос на продукцию (готовность покупать);
*	Предложение (готовность продавать);
*	Государственное регулирование цен;
*	Издержки по производству и реализации продукции;
*	Инфляция.

Риски влияющие на изменение цены:
*	Непредвиденные эпидемиологические, природные катастрофы и множество других;
*	Закрытие залежей с необходимыми природными ископаемыми;
*	Банкротство добывающих/производящих компаний.

## 1.4.	Необходимая информация для решения задачи. ##

Так как доклад связан с прогнозированием цен на бетон для строительной компании, следовательно, необходимой инофрмацией для составления датасета будет средняя цена на приобретение строительными организациями бетона и месяц закупки.

Данную информацию можно найти на открытом источнике Федеральной службе государственной статистики.

Дополнительная информация, которая поможет более точно определить прогноз:
*	Индекс цен на приобретённый строительными организациями бетон;
*	Индексы цен производителей на строительную продукцию;
*	Средне годовая цена на приобредение строительными организациями бетона;
*	Спрос среди строительных компаний в определённое время года;
*	Сезонность;
*	Количество добываемой компонентов для строительной продукции;
*	Количество мест для добычи природных компонентов и их наполненность.

Имеется некоторая специфика применения методов прогнозирования в ситуациях, связанных с риском. Велика роль функций потерь и метод её оценивания, в том числе в экономических терминах. В конкретных областях используют вероятностный анализ безопасности (для атомной энергетики) и другие специальные методы.

## 2. Практическая часть ##

## 2.1.	Составление примера. ##

Прогнозирование цен для строительной компании необходимо на этапе планирования распределения бюджета или составления строительной сметы. 

Строительная смета – это документ, в котором вычисляется сумма затрат на проект, расписанная по статьям расходов. 

Следовательно, в качестве примера возьмём прогнозирование цены бетона на срок 5 месяцев.

## 2.2.	Подключаемые библиотеки для работы. ##
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import io

from google.colab import files

from tensorflow.keras.layers import Dense, LSTM, GRU, Dropout
from tensorflow.keras.models import Sequential

from sklearn.preprocessing import MinMaxScaler

"""## 2.3.	Поиск и преобразование необходимой информации для обучения. ##

Для начала, загрузим заранее подготовленный файл с данными.
Где:
* Year - дата (месяц/год);
* Price - средняя цена на приобретённый строительными организациями бетон за каждый месяц;
* Company_index - индекс цены на приобретённый строительными организациями бетон; 
* Supplier_index - индекс цен производителей на строительную продукцию по Российской Федерации;
* Average_price - средняя цена на приобретённый строительными организациями бетон за весь год.
"""

file = files.upload()  # загружаем файл в ноутбук 

data = pd.read_csv(io.BytesIO(file['data.csv']))  # считываем csv-файл

print(data.head())

"""Чтобы небыло путаницы в данных, проведён перевод всех чисел к вещественному типу данных (float)."""

data['Price'] = data['Price'].astype('float')
data['Company_index'] = data['Company_index'].astype('float')
data['Supplier_index'] = data['Supplier_index'].astype('float')
data['Average_price'] = data['Average_price'].astype('float')

"""Демонстрация данных на графиках:
1. Изображены средние цены за каждый месяц и год;
2. Изображены индексы от строительных компаниях и индексы производителей.


"""

# отрисовка графика зависимости цены от времени.
plt.figure(figsize=(19, 7))
plt.plot(data['Year'].values, data['Price'].values, label='Price', color='red')
plt.xticks(np.arange(10, data.shape[0], 15))
plt.xlabel('Date')
plt.ylabel('Price')
plt.legend()
plt.show()

# отрисовка графика зависимости индексов производителей и потребителей (строительных компаний) от времени года.
plt.figure(figsize=(19, 7))
plt.plot(data['Year'].values, data['Company_index'].values, label='Company_index', color='red')
plt.plot(data['Year'].values, data['Supplier_index'].values, label='Supplier_index', color='blue')
plt.xticks(np.arange(10, data.shape[0], 15))
plt.xlabel('Date')
plt.ylabel('Index')
plt.legend()
plt.show()

"""Подготавливаем обучающую и тестовую выборку."""

num_train = 240  # кол-во элементов в обучающей выборке

# разделение данных для обучение и тестирования (Взятие одной колонки "Price")
train = data.iloc[:num_train, 1:2].values 
test = data.iloc[num_train:, 1:2].values

"""Стандартизуем данные для нейронной сети."""

sc = MinMaxScaler(feature_range=(0, 1))  # переменная для масштабирования данных в диапозоне от 0 до 1

# стандартизация данных 
train_sc = sc.fit_transform(train)
test_sc = sc.fit_transform(test)

"""Подготавливаем данные для обучения модели."""

X_train = []  
Y_train = []

window = 4  # окно разбиения данных на исходные и прогнозируемые

# разделяем данные
for i in range(window, num_train):
    X_train_ = np.reshape(train_sc[i-window:i, 0], (window, 1))
    X_train.append(X_train_)
    Y_train.append(train_sc[i, 0])

X_train = np.stack(X_train)
Y_train = np.stack(Y_train)

"""Функция создающая данные для тестирования модели."""

def create_test_data(train, test):
  X_test = []

  tmp_data = np.vstack((train, test))

  tmp = tmp_data[tmp_data.shape[0] - test.shape[0] - window:]
  tmp = tmp.reshape(-1, 1)
  tmp = sc.transform(tmp)

  num_test = tmp_data.shape[0] - num_train + window

  for i in range(window, num_test):
    X_test_ = np.reshape(tmp[i - window:i, 0], (window, 1))
    X_test.append(X_test_)

  X_test = np.stack(X_test)

  return X_test

"""## 2.4.	Составление модели нейронной сети. ##

Настраиваем входной слой.
"""

input_shape = X_train.shape[1], 1
print('input_shape={}'.format(input_shape))

"""Строим рекуррентную модель на основе LSTM."""

# Модель построенная на LSTM

model_LSTM = Sequential()

model_LSTM.add(LSTM(units=64, return_sequences=True, input_shape=input_shape))
model_LSTM.add(Dropout(0.2))
model_LSTM.add(LSTM(units=32, return_sequences=True))
model_LSTM.add(Dropout(0.2))
model_LSTM.add(LSTM(units=32, return_sequences=True))
model_LSTM.add(Dropout(0.2))
model_LSTM.add(LSTM(units=64))
model_LSTM.add(Dropout(0.2))
model_LSTM.add(Dense(units=1))

model_LSTM.summary()

"""Строим рекуррентную модель на основе GRU."""

# Модель построенная на GRU 
model_GRU = Sequential()

model_GRU.add(GRU(units=64, return_sequences=True, input_shape=input_shape))
model_GRU.add(Dropout(0.2))
model_GRU.add(GRU(units=32, return_sequences=True))
model_GRU.add(Dropout(0.2))
model_GRU.add(GRU(units=32, return_sequences=True))
model_GRU.add(Dropout(0.2))
model_GRU.add(GRU(units=64))
model_GRU.add(Dropout(0.2))
model_GRU.add(Dense(units=1))

model_GRU.summary()

"""## 2.5.	Обучение модели. ##

Обучаем LSTM модель. Исппользуем оптимизатор Adam и функцию потерь Mean Squared Error (средний квадрат ошибки).
"""

model_LSTM.compile(optimizer='adam', loss='mean_squared_error')
model_LSTM.fit(X_train, Y_train, epochs=35, batch_size=32)

"""Обучаем GRU модель. Исппользуем оптимизатор Adam и функцию потерь Mean Squared Error (средний квадрат ошибки)."""

model_GRU.compile(optimizer='adam', loss='mean_squared_error')
model_GRU.fit(X_train, Y_train, epochs=35, batch_size=32)

"""## 2.6.	Получение результата. ##

Создадим тестовые значения для проверки работоспособности модели.
"""

X_test = create_test_data(train, test)
print(X_test.shape)

"""Строим предсказание на основе тестовых данных для модели построенной на LSTM.
Высчитываем ошибки:
* MSE - Средний квадрат ошибок (mean squared error);
* MAE - Средний модуль ошибок (mean absolut error);
* RMSE - Среднеквадратичная ошибка (root mean square Error).
Стороим график.
"""

predict = model_LSTM.predict(X_test)  # предсказываем ход графика
print('test.shape={}'.format(test.shape), ' ', 'predict.shape={}'.format(predict.shape))
predict = sc.inverse_transform(predict) # возвращаем к исходному формату значения 

diff = predict - test  # ищем разницу 

# высчитываем ошибки:
print("MSE:", np.mean(diff**2))
print("MAE:", np.mean(abs(diff)))
print("RMSE:", np.sqrt(np.mean(diff**2)))

# строим график, где красным показан исходный, а синим предсказанные значения
plt.figure(figsize=(19, 7))
plt.plot(data['Year'].values, data['Price'].values, label='Price', color='red')
plt.plot(data['Year'][-predict.shape[0]:].values, predict, label='Predict price', color='Blue')
plt.xticks(np.arange(10, data.shape[0], 15))
plt.title('Price Prediction LSTM')
plt.xlabel('Date')
plt.ylabel('Price/Predict')
plt.legend()
plt.show()

"""Строим предсказание на основе тестовых данных для модели построенной на GRU.
Высчитываем ошибки:
* MSE - Средний квадрат ошибок (mean squared error);
* MAE - Средний модуль ошибок (mean absolut error);
* RMSE - Среднеквадратичная ошибка (root mean square Error).
Стороим график.
"""

predict = model_GRU.predict(X_test)  # предсказываем ход графика
print('test.shape={}'.format(test.shape), ' ', 'predict.shape={}'.format(predict.shape))
predict = sc.inverse_transform(predict) # возвращаем к исходному формату значения 

diff = predict - test  # ищем разницу 

# высчитываем ошибки:
print("MSE:", np.mean(diff**2))
print("MAE:", np.mean(abs(diff)))
print("RMSE:", np.sqrt(np.mean(diff**2)))

# строим график, где красным показан исходный, а синим предсказанные значения
plt.figure(figsize=(19, 7))
plt.plot(data['Year'].values, data['Price'].values, label='Price', color='red')
plt.plot(data['Year'][-predict.shape[0]:].values, predict, label='Predict price', color='Blue')
plt.xticks(np.arange(10, data.shape[0], 15))
plt.title('Price Prediction GRU')
plt.xlabel('Date')
plt.ylabel('Price/Predict')
plt.legend()
plt.show()

"""Попробуем предсказать ход цены на 5 месяцев вперёд с помощью модели построенной на LSTM и построенной на GRU. Для этого будем использовать цикл, где каждое будущее предсказание будет основываться на предыдущем.
Подготавливаем дополнительные данные для модели LSTM.
"""

pred_ = predict[-1].copy()
prediction_full = []
data_copy = data.iloc[:, 1:2][1:].values

for j in range(5):
    df_ = np.vstack((data_copy, pred_))
    test_ = df_[num_train:]
    test_sc_ = sc.fit_transform(test_)

    X_test_new = create_test_data(train, test_)

    predict_ = model_LSTM.predict(X_test_new)
    pred_ = sc.inverse_transform(predict_)
    prediction_full.append(pred_[-1][0])
    data_copy = df_[j:]

prediction_full_new_LSTM = np.vstack((predict, np.array(prediction_full).reshape(-1, 1)))

"""Обновляем данные для модели GRU и повторяем действие."""

pred_ = predict[-1].copy()
prediction_full = []
data_copy = data.iloc[:, 1:2][1:].values

for j in range(5):
    df_ = np.vstack((data_copy, pred_))
    test_ = df_[num_train:]
    test_sc_ = sc.fit_transform(test_)

    X_test_new = create_test_data(train, test_)

    predict_ = model_GRU.predict(X_test_new)
    pred_ = sc.inverse_transform(predict_)
    prediction_full.append(pred_[-1][0])
    data_copy = df_[j:]

prediction_full_new_GRU = np.vstack((predict, np.array(prediction_full).reshape(-1, 1)))

"""Создаём дополнительный переменную для времени, обновляем её для предсказанных значений."""

df_date = data[['Year']]

for h in range(5):
    df_date_add = pd.to_datetime(df_date['Year'].iloc[-1]) + pd.DateOffset(months=1)
    df_date_add = pd.DataFrame([df_date_add.strftime("%m-%Y")], columns=['Year'])
    df_date = df_date.append(df_date_add)
df_date = df_date.reset_index(drop=True)

"""Строим графики, где:
1. Предсказание на основе модели на LSTM;
2. Предсказание на основе модели на GRU.
"""

plt.figure(figsize=(19, 7))
plt.plot(data['Year'].values, data['Price'], color='red', label='Real price')
plt.plot(df_date['Year'][-prediction_full_new_LSTM.shape[0]:].values, prediction_full_new_LSTM, color='blue', label='Predicted price')
plt.xticks(np.arange(10, data.shape[0], 15))
plt.title('Price Prediction LSTM')
plt.xlabel('Date')
plt.ylabel('Price')
plt.legend()
plt.show()

plt.figure(figsize=(19, 7))
plt.plot(data['Year'].values, data['Price'], color='red', label='Real price')
plt.plot(df_date['Year'][-prediction_full_new_GRU.shape[0]:].values, prediction_full_new_GRU, color='blue', label='Predicted price')
plt.xticks(np.arange(10, data.shape[0], 15))
plt.title('Price Prediction GRU')
plt.xlabel('Date')
plt.ylabel('Price')
plt.legend()
plt.show()

"""## Заключение. ##

Качество прогноза зависит больше всего от собранной информации. Следовательно, сбор, анализирование и составление данных является важным этапом решения поставленной задачи.

## Список используемой литературы. ##

1.	Гос. статья про прогнозирование цен на товары: 
https://ac.gov.ru/news/page/v-rossii-poavitsa-algoritm-dla-prognozirovania-cen-na-tovary-i-uslugi-26955
2.	Прогнозирование цен(формулы и теория):
https://studme.org/1640011611735/menedzhment/prognozirovanie_tsen
3.	Метод экспоненциального сглаживания: 
https://studme.org/1115121211736/menedzhment/metod_eksponentsialnogo_sglazhivaniya
4.	Прогнозирование цен и спроса на природные ресурсы на основе статистических моделей (формулы и теория): 
https://studme.org/81830/ekonomika/prognozirovanie_sprosa_prirodnye_resursy_osnove_statisticheskih_modeley#778
5.	Федеральная служба государственной статистики:
https://rosstat.gov.ru/price
"""